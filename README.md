# «Правильный» релиз

Т.к. в последние месяцы работы в компании, я занимался релизами почти всех веб-приложений, мне удалось найти, на мой взгляд, оптимальный подход к этому. Ниже я опишу и сам процесс подготовки и выкладки релиза, а также инструментарий, который необходим для этого.

## В общем

Итак, ваш менеджер проекта дает вам задачу подготвить новый релиз приложения. В свою очередь вам необходимо уточнить:

### Куда выкладывать релиз — dev, test, staging или prod?

Конкретно, у «роботов», я не встречал, чтобы были все 4 площадки. Скорее всего есть 2 — dev(test) и staging. Но в идеале, должны быть все 4. Поэтому ниже я опишу, для чего каждая из них нужна:

* **dev** – это песочница для разработчиков, хотя в случае веб-приложений она не очень нужна, т.к. веб-приложение, зачастую, можно целиком запустить локально;

* **test** – сюда выкладывают сборки для тестирования; обычно это предрелизные сборки;

* **staging** — площадка, которая по своей конфигурации максимально схожа с продакшеном, но при этом доступна только изнутри; используется для тестирования каких-либо опасных изменений в окружении максимально приближенном к боевому;

* **prod** — он и в Африке прод — на нем должна крутиться последняя стабильная версия приложения и сюда же выкладываются hotfix'ы;

### Какой номер версии приложения ставить?

Это может быть важно, т.к. менеджер мог договориться с заказчиком о передаче конкретной версии приложения. В последнее время я старался следовать semver'у, хотя это не всегда получалось. Кратко о нем:

1. Номер версии состоит из 3-х цифр, разделенных точками - X.Y.Z:

    * **X** – это мажорный релиз (т.е. изменение этой цифры говорит, о том, что вы релизите мажорную версию вашего прилоежения), который ломает или не совместим по API с предыдущей версией. К примеру, вы переписали роутинг приложения или полностью поменяли дизайн. Зачастую, мажорной версией становится версия с большим кол-вом новых фич. Согласно semver'у, **X** >= 1. Т.е. `0.1.2` - некорректная версия.

    * **Y** — это минорный релиз — вы сделали изменения, но они обратно-совместимы с предыдущей версией. Обычно, это небольшое кол-во новых фич.
        
    * **Z** - багфикс релиз - незначительные изменения, либо фикс каких-либо багов.

2. Номер версии может иметь постфикс:
    
    * **-rc.X** - версия релиз-кандидат, пре-релизная версия приложения. Используйте ее, когда требуется выложить релиз для тестирования;
        
    * **-hotfix.X** - хотфиксовая версия приложения;

## Подготовка релиза

Итак вы определились с площадкой и номером версии. Переходим к подготовке релиза. В большинстве проектов используется _git flow_. Помимо самой [методологии](http://nvie.com/posts/a-successful-git-branching-model/), существует еще и набор полезных [тулзов](https://github.com/nvie/gitflow), которые позволяют упростить ее применение. Я крайне рекомендую, установить их, т.к. при подготовке релиза они значительно сократят кол-во вводимых команд. Далее, я подразумеваю, что у вас стоят утилиты _git flow_.

### Релизная ветка

Согласно методологии _git flow_, каждый релиз должен быть выделен в отдельную ветку. По умолчанию, ветки релизов имеют префикс `release/`. Допустим вы готовите релиз `1.2.3`. Тогда вы создаете ветку `release/1.2.3`, которая базируется на текущей версии devel'а: `git flow release start 1.2.3`. Если созданная релизная ветка содержит все необходимые изменения, то можно обновить версию в `package.json`. Какую версию поставить? Я завел себе такое правило: если это финальная версия, которая будет отдана клиенту, то просто `1.2.3`. Если это предрелизная версия для внутреннего тестирования, то `1.2.3-rc.X`, где **Х** - это порядковый номер релиз-кандидата.

### Release notes

Самая геморная, но при этом одна из самых важных частей процесса релиза - подготовка release notes. Они нужны не только тестировщикам, но и вам, т.к. в дальнейшем облегчат поиск по истории. Я писал релиз ноуты в формате [Markdown](https://daringfireball.net/projects/markdown/syntax). Он простой в написании, читабельный даже в простом блокноте и поддерживается GitHub'ом и GitLab'ом, в качестве формата для комментариев (и для релиз ноутов) по умолчанию. Для составления релиз ноутсов я использовал простой bash-скрипт, который собирал названия тасков в Jira из commit-сообщений, а затем передавал их в специальную утилитку [jira-cmd](https://github.com/germanrcuriel/jira-cmd), которая уже брала из Jira описание для каждой из задач. Выглядел он примерно так:

```bash
git log --no-merges --pretty=format:"%B" v1.2.2..HEAD |\
    grep RDAL | sort | uniq |\
    sed -re 's/^.*(RDAL-[0-9]{2,4}).*$/\1/' |\
    xargs -I {} echo {} - `jira show -d {}`
```

На выходе вы получите список багов с описанием из Jira. Остается только рассортировать из по типам (Features, Bugs) и дополнить изменениями, которые не были заведены в Jira. На выходе нужно получить нечто подобное:

```markdown
Features:

  * [RDAL-1001](https://redmadrobot.atlassian.net/browse/RDAL-1001) — Увеличить кол-во операторов в списке
  * [RDAL-982](https://redmadrobot.atlassian.net/browse/RDAL-982) — Правила линий поддержки
  * [RDAL-984](https://redmadrobot.atlassian.net/browse/RDAL-984) — Заглушки,если аватарка не установлена

Bugs:

  * [AVD-245](https://redmadrobot.atlassian.net/browse/AVD-245) — перенос слов
  * [RDAL-1004](https://redmadrobot.atlassian.net/browse/RDAL-1004) — [Статистика] Если не было обращений показывается некорректное среднее время обработки
```

Этот список уже можно отправлять QA, предварительно незабыв перевести все задачи из списка в статус _Resolved_ и проставив соответсвующую версию в Jira.

### Finally

После того, как вы закончили работу над релизной версией, ее необходимо вмержить в master и в devel и передать заказчику. Вот тут _git-flow_ значительно упрощает процесс. С помощью одной команды - `git flow release finish 1.2.3` - вы можете закомитите релизную ветку и в master и в devel, установите соответствующий тэг, а также может запушить все изменения на удаленный репозиторий. После push'а, не поленитесь добавить релиз-ноуты к соответствующей версии и туда. Это в ваших же интересах, т.к. тогда вы сможете быстро ответить на вопрос менеджера о том, в какой версии и какие изменения были внесены, без рысканья по Jira и письмам.

После этого можете готовить приложение для передачи клиенту. Каким образом? - Зависит от конктреного приложения и клиента. Кому-то архив, кому-то пуш в репозиторий, а кому-то docker-образ.

## Hotfix

Факапы, также как и shit имееют свойство случаться. Допустим вы выложили (читай «передали клиенту») версию с каким-то критическим багом. В этом случае вам нужно сделать hotfix - быстрое исправление. Для этого также можно использовать _git-flow_. `git flow hotfix start 1.2.3-hotfix.1` - создаст новую ветку на основе текущего master'а. После внесения необходимых исправлений, не забудьте обновить версию в `package.json`. Теперь с помощью одной команды - `git flow hotfix finish 1.2.3-hotfix.1` - вы вмержите текущую ветку в master и devel, проставите сооветствующий тэг в репозитории, а также можете запушить ее на сервер.